{
    "zadaci":[
        {
            "z":"Napisati korisnički definisanu funkciju koja vraća nisku sa imenima. Kao arguemtn se prosleđuje karakter za pol. Ako pol nije m ili z vratiti nisku 'Pol ne moze biti *prosledjen_argument*'. Sortirati po imenu. ",
            "r":[
                "CREATE FUNCTION STUDENTI(POLARG CHAR) <br>RETURNS VARCHAR(4000)<br>RETURN <br><tab></tab>CASE<br><tab></tab><tab></tab>WHEN LOWER(POLARG) IN ('z', 'm') THEN<br><tab></tab><tab></tab><tab></tab>(SELECT LISTAGG(DISTINCT IME, ',') WITHIN GROUP (ORDER BY IME ASC)<br><tab></tab><tab></tab><tab></tab>FROM DA.DOSIJE<br><tab></tab><tab></tab><tab></tab>WHERE LOWER(POLARG)=POL)<br><tab></tab><tab></tab>ELSE <br><tab></tab><tab></tab><tab></tab>'Pol ne moze biti ' || POLARG<br><tab></tab>END;",
                "VALUES STUDENTI('X');",
                "VALUES STUDENTI('M');"
            ]
        },
        {
            "z": "Napisati korisnički definisanu funkciju koja vraća nisku sa indeksima studenata koji imaju prosek jednak vrednosti prosleđenoj kao argument. Ispret niske sa indeksima ispisti koliko ima indeksa, indekse razdvojiti crticama. Prosek gledati na dve decimale. Izlaz treba da bude na primer: '2:20170325-20170349'.",
            "r":[
                "CREATE FUNCTION STUDENTI_SA_PROSEKOM(X FLOAT)<br>RETURNS VARCHAR(4000)<br>RETURN <br><tab></tab>WITH PROSECI AS (<br><tab></tab><tab></tab>SELECT INDEKS, DECIMAL(AVG(OCENA+0.0), 4, 2) PROSEK<br><tab></tab><tab></tab>FROM DA.ISPIT <br><tab></tab><tab></tab>WHERE OCENA>5 AND STATUS='o'<br><tab></tab><tab></tab>GROUP BY INDEKS<br><tab></tab>)<br><tab></tab>SELECT COUNT(*) || ': ' || LISTAGG(INDEKS, '-')<br><tab></tab>FROM PROSECI<br><tab></tab>WHERE PROSEK=DECIMAL(X, 4, 2);",
                "VALUES (9.96, STUDENTI_SA_PROSEKOM(9.96)),<br><tab></tab>(10,  STUDENTI_SA_PROSEKOM(10)),<br><tab></tab>(6,  STUDENTI_SA_PROSEKOM(6));"
            ]
        },
        {
            "z": "Napisati naredbu na SQL-u koja:<ul><li>pravi tabelu predmet_student koja čuva podatke koliko studenata je položilo koji predmet. Tabela ima kolone: idpredmeta (tipa integer) i student (tipa smallint).</li><li>unosi u tabelu predmet_student podatke o obaveznim predmetima na smeru Informatika na osnovnim akademskim studijama (može se uzeti da je id 103). Za svaki predmet uneti podatak da ga je položilo 5 studenata.</li><li>ažurira tabelu predmet_student, tako što predmetima o kojima postoji evidencija ažurira broj studenata koji su ga položili, a za predmete o kojima ne postoji evidencija unosi podatke.</ul>",
            "r":[
                "DROP TABLE IF EXISTS PREDMET_STUDENT;<br><br>CREATE TABLE PREDMET_STUDENT (<br><tab></tab>IDPREDMETA INTEGER,<br><tab></tab>STUDENT SMALLINT<br>);<br><br>INSERT INTO PREDMET_STUDENT <br>SELECT IDPREDMETA, 5<br>FROM DA.PREDMETPROGRAMA<br>WHERE IDPROGRAMA=103 AND VRSTA='obavezan';<br><br>MERGE INTO PREDMET_STUDENT PS<br>USING (<br><tab></tab>SELECT IDPREDMETA, COUNT(*) BR<br><tab></tab>FROM DA.ISPIT<br><tab></tab>WHERE OCENA>5 AND STATUS='o'<br><tab></tab>GROUP BY IDPREDMETA<br><tab></tab>) AS P<br>ON PS.IDPREDMETA=P.IDPREDMETA<br>WHEN MATCHED THEN <br><tab></tab>UPDATE <br><tab></tab>SET STUDENT=BR<br>WHEN NOT MATCHED THEN<br><tab></tab>INSERT<br><tab></tab>VALUES (IDPREDMETA, BR);"
            ]
        },
        {
            "z":"Napisati naredbu na SQL-u koja:<ul> <li>pravi tabelu student_podaci sa kolonama: indeks (tipa integer), broj _predmeta (tipa smallint), prosek (tipa float) i datupisa (tipa date);</li> <li>u tabelu student_podaci unosi indeks, broj položenih predmeta i prosek za studente koji imaju prosek iznad 8 i nisu diplomirali; za studente koji su diplomirali kao broj predmeta uneti vrednost 10, a kao prosek vrednost 10;</li><li>ažurira tabelu student_podaci tako što studentima o kojima u tabeli postoje podaci i koji su:<ul>             <li>diplomirali ažurira datum upisa na fakultet</li>             <li>trenutno na budžetu ažurira broj položenih predmeta i prosek;</li>             <li>studente koji su ispisani briše iz tabele;</li>             <li>unosi podatke o studentima koji nisu ispisani i o njima ne postoje podaci u tabeli student_podaci; uneti indeks, broj položenih predmeta i prosek;</li></ul></li><li>uklanja tabelu student_podaci.</li></ul>",             
            "r":[
                "DROP TABLE IF EXISTS STUDENT_PODACI;<br><br>CREATE TABLE STUDENT_PODACI (<br><tab></tab>INDEKS INTEGER,<br><tab></tab>BROJ_PREDMETA SMALLINT,<br><tab></tab>PROSEK FLOAT,<br><tab></tab>DATUPISA DATE<br>);<br><br>INSERT INTO STUDENT_PODACI(INDEKS, BROJ_PREDMETA, PROSEK)<br>SELECT INDEKS, COUNT(*), AVG(OCENA*1.0)<br>FROM DA.ISPIT I<br>WHERE INDEKS NOT IN (<br><tab></tab>SELECT INDEKS<br><tab></tab>FROM DA.DOSIJE D JOIN DA.STUDENTSKISTATUS SS<br><tab></tab><tab></tab>ON D.IDSTATUSA = SS.ID<br><tab></tab>WHERE SS.NAZIV='Diplomirao'<br>) AND OCENA>5 AND STATUS='o'<br>GROUP BY INDEKS<br>HAVING AVG(OCENA+0.0) > 8<br>UNION<br>SELECT INDEKS, 10, 10<br>FROM DA.DOSIJE D JOIN DA.STUDENTSKISTATUS SS<br><tab></tab>ON D.IDSTATUSA = SS.ID<br>WHERE SS.NAZIV='Diplomirao';<br><br>MERGE INTO STUDENT_PODACI SP<br>USING (<br><tab></tab>SELECT D.INDEKS, AVG(OCENA*1.0) PROSEK, COUNT(*) PREDMETI, SS.NAZIV STATUSSTUDENTA, DATUPISA DATUMUPISA<br><tab></tab>FROM DA.ISPIT I JOIN DA.DOSIJE D<br><tab></tab><tab></tab><tab></tab>ON I.INDEKS = D.INDEKS<br><tab></tab><tab></tab>JOIN DA.STUDENTSKISTATUS SS<br><tab></tab><tab></tab><tab></tab>ON SS.ID = D.IDSTATUSA<br><tab></tab>WHERE OCENA>5 AND STATUS='o'<br><tab></tab>GROUP BY D.INDEKS, DATUPISA, SS.NAZIV<br>) AS TMP<br>ON SP.INDEKS = TMP.INDEKS<br>WHEN MATCHED AND TMP.STATUSSTUDENTA='Diplomirao' THEN<br><tab></tab>UPDATE<br><tab></tab>SET SP.DATUPISA = TMP.DATUMUPISA<br>WHEN MATCHED AND TMP.STATUSSTUDENTA='Budzet' THEN<br><tab></tab>UPDATE<br><tab></tab>SET (BROJ_PREDMETA, PROSEK) = (TMP.PREDMETI, TMP.PROSEK)<br>WHEN MATCHED AND LOWER(TMP.STATUSSTUDENTA) LIKE '%ispis%' THEN<br><tab></tab>DELETE<br>WHEN NOT MATCHED AND LOWER(TMP.STATUSSTUDENTA) NOT LIKE '%ispis%' THEN<br><tab></tab>INSERT (INDEKS, BROJ_PREDMETA, PROSEK)<br><tab></tab>VALUES (TMP.INDEKS, TMP.PREDMETI, TMP.PROSEK)<br>ELSE IGNORE;<br><br>DROP TABLE STUDENT_PODACI;"
            ],
            "n": "Na početku brišemo tabelu ako postoji, da ne bi dobili grešku ako slučajno postoji. <br>Student je ispisan ako ima neki od narednih statusa: \"Ispis po resenju\", \"Ispis gostujuceg\", \"Ispis zbog prekoracanje\", \"Ispisan\". Ove mogućnosti možemo objediniti sa like '%ispis%'."
        },
        {
            "z": "Napraviti okidač koji sprečava brisanje studenata koji su diplomirali. U tabelu uneti studenta koji je diplomirao i proveriti da li trigger radi. Na kraju obrisati trigger.",
            "r":[
                "--#SET TERMINATOR @<br><br><br>CREATE TRIGGER BRISANJE_STUDENTA<br>BEFORE DELETE<br>ON DA.DOSIJE<br>REFERENCING OLD AS STARI<br>FOR EACH ROW<br>WHEN (STARI.IDSTATUSA IN (<br><tab></tab>SELECT ID<br><tab></tab>FROM DA.STUDENTSKISTATUS<br><tab></tab>WHERE NAZIV='Diplomirao'<br>))<br>BEGIN ATOMIC<br>SIGNAL SQLSTATE '75000' ('Ne mozete obrisati studenta koji je diplomirao');<br>END @",
                "INSERT INTO DA.DOSIJE (INDEKS, IDPROGRAMA, IME, PREZIME, IDSTATUSA, DATUPISA)<br>VALUES (20220001, 103, 'Marko', 'Petrovic', -2, current date)@",
                "DELETE FROM DA.DOSIJE<br>WHERE INDEKS=20220001@",
                "DROP TRIGGER BRISANJE_STUDENTA@"
            ]
        },
        {
            "z": "Napraviti okidač koji dozvoljava ažuriranje broja espb bodova predmetima samo za jedan bod. Ako je nova vrednost espb bodova veća od postojeće, broj bodova se povećava za 1, a ako je manja smajuje se za 1. ",
            "r":[
                "--#SET TERMINATOR @<br>CREATE TRIGGER PROMENI_ESPB<br>BEFORE UPDATE OF ESPB<br>ON DA.PREDMET<br>REFERENCING OLD AS O<br><tab></tab>NEW AS N<br>FOR EACH ROW<br>BEGIN ATOMIC<br><tab></tab>SET N.ESPB = CASE<br><tab></tab><tab></tab>WHEN O.ESPB > N.ESPB THEN O.ESPB-1<br><tab></tab><tab></tab>WHEN O.ESPB < N.ESPB THEN O.ESPB+1<br><tab></tab><tab></tab>ELSE O.ESPB<br><tab></tab>END;<br>END@",
                "INSERT INTO DA.PREDMET(ID, OZNAKA, NAZIV, ESPB)<br>VALUES(5000, 'X', 'X', 4)@<br><br>UPDATE DA.PREDMET<br>SET ESPB=10<br>WHERE ID=5000@<br><br>SELECT *<br>FROM DA.PREDMET<br>WHERE ID=5000@<br><br>UPDATE DA.PREDMET<br>SET ESPB=1<br>WHERE ID=5000@<br><br>SELECT *<br>FROM DA.PREDMET<br>WHERE ID=5000@",
                "DROP TRIGGER PROMENI_ESPB@"
            ]
        },
        {
            "z":"<ul> <li>Napraviti tabelu broj_predmeta koja ima jednu kolonu broj tipa smallint i u nju uneti jedan entitet koji predstavlja broj predmeta u tabeli predmet.</li> <li>Napraviti okidač koji ažurira tabelu broj_predmeta tako što povećava vrednosti u koloni broj za 1 kada se unese novi predmet u tabelu predmet.</li> <li>Napisati okidač koji ažurira tabelu broj_predmeta tako što smanjuje vrednost u koloni broj za 1 kada se obriše predmet iz tabele predmet.</li> <li>Uneti podatke o novom predmetu čiji je id 2002, oznaka predm1, naziv Predmet 1, i ima 15 espb.</li> </ul>",
            "r":[
                "--#SET TERMINATOR @<br><br>CREATE TABLE BROJ_PREDMETA (<br><tab></tab>BROJ SMALLINT<br>)@<br><br>INSERT INTO BROJ_PREDMETA<br>SELECT COUNT(*)<br>FROM DA.PREDMET@<br><br>SELECT *<br>FROM BROJ_PREDMETA@",
                "CREATE TRIGGER UNETI_PREDMET<br>AFTER INSERT <br>ON DA.PREDMET<br>FOR EACH ROW<br>BEGIN ATOMIC<br><tab></tab>UPDATE BROJ_PREDMETA<br><tab></tab>SET BROJ = BROJ + 1;<br>END@",
                "CREATE TRIGGER OBRISI_PREDMET<br>AFTER DELETE <br>ON DA.PREDMET<br>FOR EACH ROW<br>BEGIN ATOMIC<br><tab></tab>UPDATE BROJ_PREDMETA<br><tab></tab>SET BROJ = BROJ - 1;<br>END@",
                "INSERT INTO DA.PREDMET(ID, OZNAKA, NAZIV, ESPB)<br>VALUES(2002, 'predm1', 'Predmet 1', 15)@<br><br>SELECT *<br>FROM BROJ_PREDMETA@<br><br>DELETE FROM DA.PREDMET<br>WHERE ID=2002@<br><br>SELECT *<br>FROM BROJ_PREDMETA@",
                "DROP TABLE BROJ_PREDMETA@<br>DROP TRIGGER UNETI_PREDMET@<br>DROP TRIGGER OBRISI_PREDMET@",
                "CREATE TRIGGER PROMENA_PREDMETA<br>AFTER INSERT OR DELETE <br>ON DA.PREDMET<br>FOR EACH ROW<br>BEGIN <br><tab></tab>IF INSERTING THEN <br><tab></tab><tab></tab>UPDATE BROJ_PREDMETA<br><tab></tab><tab></tab>SET BROJ = BROJ + 1;<br><tab></tab>ELSEIF DELETING THEN<br><tab></tab><tab></tab>UPDATE BROJ_PREDMETA<br><tab></tab><tab></tab>SET BROJ = BROJ-1;<br><tab></tab>END IF;<br>END@"
            ]
        }, 
        {
            "z": "<ul><li>Napraviti tabelu student_polozeno koja za svakog studenta koji je položio barem jedan predmet sadrži podatak koliko je espb bodovoa položio. Tabela ima kolone indeks i espb.</li><li>Napraviti tabelu predmet_polozeno koja za svaki predmet koji je položio barem jedan student sadrži podatak koliko je studenata položilo taj predmet. Tabela ima kolone idpredmeta i brojstudenata.</li><li>Uneti podatke u tabelu student_polozeno za studente koji su položili sve obavezne predmete na smeru koji studiraju.</li><li>Napisati naredbu koja menja tabelu student_polozeno tako što ažurira broj položenih espb bodova za studente o kojima sadrži podatke, a unosi informaicje za studente o kojima ne postoje podaci u tabeli student_polozeno.</li><li>Uneti podatke u tabelu predmet_polozeno.</li><li>Napraviti okidač koji nakon unosa položenog ispita ažurira tabele student_polozeno i predmet_polozeno tako da sadrže podatak o novom ispitu.</li><li>Uneti podatak da je student sa indeksom 20150320 polagao predmet sa id 2010 u ispitnom roku jun2 2017/2018. šk. godine. Student je ispit položio sa 95 poena i dobio ocenu 10.</li><li>Uneti podatak da je student sa indeksom 20152003 polagao predmet sa id 1695 u ispitnom roku jun1 2017/2018. šk. godine. Student je ispit položio sa 95 poena i dobio je ocenu 10.</li></ul>",
            "r":[
                "--#SET TERMINATOR @<br><br>CREATE TABLE STUDENT_POLOZENO (<br><tab></tab>INDEKS INTEGER NOT NULL PRIMARY KEY,<br><tab></tab>ESPB SMALLINT<br>)@",
                "CREATE TABLE PREDMET_POLOZENO (<br><tab></tab>IDPREDMETA INTEGER,<br><tab></tab>BROJSTUDENATA SMALLINT<br>)@",
                "INSERT INTO STUDENT_POLOZENO<br>SELECT D.INDEKS, SUM(ESPB)<br>FROM DA.DOSIJE D JOIN DA.ISPIT I<br><tab></tab><tab></tab>ON D.INDEKS = I.INDEKS<br><tab></tab>JOIN DA.PREDMET P<br><tab></tab><tab></tab>ON P.ID = I.IDPREDMETA<br>GROUP BY D.INDEKS, IDPROGRAMA<br>HAVING NOT EXISTS(<br><tab></tab>SELECT *<br><tab></tab>FROM DA.PREDMETPROGRAMA PP<br><tab></tab>WHERE PP.IDPROGRAMA = D.IDPROGRAMA AND VRSTA='obavezan'<br><tab></tab><tab></tab>AND NOT EXISTS(<br><tab></tab><tab></tab><tab></tab>SELECT *<br><tab></tab><tab></tab><tab></tab>FROM DA.ISPIT I1<br><tab></tab><tab></tab><tab></tab>WHERE I1.INDEKS=D.INDEKS<br><tab></tab><tab></tab><tab></tab><tab></tab>AND I1.IDPREDMETA=PP.IDPREDMETA<br><tab></tab><tab></tab><tab></tab><tab></tab>AND STATUS='o' AND OCENA>5<br><tab></tab><tab></tab>)<br>)@",
                "MERGE INTO STUDENT_POLOZENO SP<br>USING (<br><tab></tab>SELECT INDEKS, SUM(ESPB) POLOZENO<br><tab></tab>FROM DA.ISPIT I JOIN DA.PREDMET P<br><tab></tab><tab></tab>ON P.ID = I.IDPREDMETA<br><tab></tab>WHERE OCENA>5 AND STATUS='o'<br><tab></tab>GROUP BY INDEKS<br>) AS TMP<br>ON SP.INDEKS = TMP.INDEKS<br>WHEN MATCHED THEN<br><tab></tab>UPDATE <br><tab></tab>SET ESPB = TMP.POLOZENO<br>WHEN NOT MATCHED THEN<br><tab></tab>INSERT<br><tab></tab>VALUES(TMP.INDEKS, TMP.POLOZENO)@",
                "INSERT INTO PREDMET_POLOZENO<br>SELECT IDPREDMETA, COUNT(*)<br>FROM DA.ISPIT <br>WHERE OCENA>5 AND STATUS='o'<br>GROUP BY IDPREDMETA@",
                "CREATE TRIGGER NOVI_ISPIT<br>AFTER INSERT <br>ON DA.ISPIT<br>REFERENCING NEW AS NEW<br>FOR EACH ROW<br>WHEN (NEW.OCENA>5 AND NEW.STATUS='o')<br>BEGIN ATOMIC<br><tab></tab>IF NEW.INDEKS IN (SELECT INDEKS FROM STUDENT_POLOZENO) THEN<br><tab></tab><tab></tab>UPDATE STUDENT_POLOZENO<br><tab></tab><tab></tab>SET ESPB = ESPB + (<br><tab></tab><tab></tab><tab></tab>SELECT ESPB<br><tab></tab><tab></tab><tab></tab>FROM DA.PREDMET<br><tab></tab><tab></tab><tab></tab>WHERE ID = NEW.IDPREDMETA)<br><tab></tab><tab></tab>WHERE INDEKS=NEW.INDEKS;<br><tab></tab>ELSE<br><tab></tab><tab></tab>INSERT INTO STUDENT_POLOZENO<br><tab></tab><tab></tab>SELECT NEW.INDEKS, ESPB<br><tab></tab><tab></tab>FROM DA.PREDMET<br><tab></tab><tab></tab>WHERE ID=NEW.IDPREDMETA;<br><tab></tab>END IF;<br><tab></tab><tab></tab><br><tab></tab>IF NEW.IDPREDMETA IN (SELECT IDPREDMETA FROM PREDMET_POLOZENO) THEN<br><tab></tab><tab></tab>UPDATE PREDMET_POLOZENO<br><tab></tab><tab></tab>SET BROJSTUDENATA = BROJSTUDENATA + 1<br><tab></tab><tab></tab>WHERE IDPREDMETA=NEW.IDPREDMETA;<br><tab></tab>ELSE<br><tab></tab><tab></tab>INSERT INTO PREDMET_POLOZENO<br><tab></tab><tab></tab>VALUES (NEW.IDPREDMETA, 1);<br><tab></tab>END IF;<br>END@",
                "INSERT INTO DA.ISPIT (INDEKS, IDPREDMETA, OZNAKAROKA, SKGODINA, STATUS, POENI, OCENA)<br>VALUES (20150320, 2010, 'jun2', 2017, 'o', 95, 10)@",
                "INSERT INTO DA.ISPIT (INDEKS, IDPREDMETA, OZNAKAROKA, SKGODINA, STATUS, POENI, OCENA)<br>VALUES (20152003, 1695, 'jun2', 2017, 'o', 95, 10)@"
            ],
            "n": "U rešenju druge tačke zadatka smo uslov umesto u HAVING mogli staviti u WHARE. Razlika je u tome što ako stavimo u HAVING onda se ovo računa jednom za svaku grupu (u ovom slučaju se mora grupisati i po IDPROGRAMA da bi to mogli da iskorisitmo u having), dok se u drugom slučaju računa za svaki red. Prema tome ova verzija je efikasnija.<br>Pri pravljenju okidača u ovom zadatku imamo liniju REFERENCING NEW AS NEW. Iako deluje nepotrebno bez ovoga neće raditi. Umesto da novo ime bude new mogli smo staviti bilo šta drugo, npr n, ili novo."
        }
    ],
    "zadaciZaVezbanje":[
        "Fakultet organizuje putovanje za studente. Puna cena putovanja je 25000 RSD.  <ul><li> Napraviti tabelu <em>putovanje</em> koja čuva podatke o studentima zainteresovanim za putovanje. Tabela ima kolone:<ul><li>indeks - indeks studenta </li><li>cena  - cena putovanja za studenta </li><li>status_placanja - status plaćanja </li></ul>Definisati primarni ključ i strani ključ na tabelu <em>dosije</em>.</li><li>Napisati naredbu koja u tabeli <em>putovanje</em> postavlja ograničenja:<ul><li> vrednost kolone <em>status_placanja</em> može biti <em>placeno</em>, <em>oslobodjen</em>, <em>neplaceno</em> </li><li>podrazumevana vrednost kolone <em>status_placanja</em>  je <em>neplaceno</em> </li></ul></li><li>Napisati naredbu koja u tabelu <em>putovanje</em> unosi podatke za studente koji su u 2016/2017. školskoj godini položili bar polovinu upisanih ESPB u toj školskoj godini. </li><li>Napisati naredbu koja menja tabelu <em>putovanje</em> tako da sadrži prijave svih studenata koji nisu diplomirali. Studentima o kojima postoje podaci u tabeli  putovanje ažurirati podatke na sledeći način:<ul><li> ako je student bar na polovini položenih ispita dobio ocenu 10 oslobođen je plaćanja putovanja. Postaviti cenu na 0 i status plaćanja na <em>oslobodjen</em> </li><li>ostalim studentima izračunati cenu prema formuli: cena putovanja se umanjuje za procenat koji odgovara procentu ispita koje je student položio sa ocenom 10 u odnosu na njegov brojpoloženih ispita.</li></ul>Za studente o kojima ne postoje podaci u tabeli  putovanje uneti podatke. Uneti indeks i cenu. Punu cenu putovanja  umanjiti za procenat koji odgovara procentu ispita koje je student položio sa ocenom 10. </li><li>Napisati naredbu za brisanje tabele putovanje. </li></ul>",
        "Napraviti okidač koji sprečava brisanje predmeta sa brojem espb bodova većim od 15.",
        "Za sve studente osnovnih studija izdvojiti pregledne podatke o količini ispunjenih obaveza.Izdvojiti broj indeksa, oznaku smera, ukupan broj ESPB potrebnih za završetak studija, ukupan broj ESPB iz položenih predmeta, procenat položenosti ESPB, ukupan broj ESPB koje nose obavezni predmeti, ukupan broj ESPB koje nose položeni obavezni predmeti, procenat položenosti ESPB koje nose obavezni položeni predmeti. Izveštaj urediti po procentu položenosti ESPB."
    ]
}