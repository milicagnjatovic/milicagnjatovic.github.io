<!DOCTYPE html>

<html>
<head>
    <title>Milica Gnjatović</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="public/css/index.css">  
    <link rel="stylesheet" type="text/css" href="public/css/casovi.css">  
    <script type="text/javascript" src="public/js/index.js"></script>
    <script type="text/javascript" src="public/js/gen_cas.js"></script>
</head>

<body>

    
    <div id = "header">
        <h2>Milica Gnjatović</h2>

            <table id="menu">
                <tr>
                    <th> <a href="./index.html"> časovi </a> </th>                    
                    <th> <a href="./about_me.html"> o meni </a> </th>
                </tr>
            </table>

    </div>

    <a href="#left_menu" id="pocetak">POČETAK</a>

    <main>
        <div id="left_menu">
            <table>
                <tr><td><a href="#podesavanje_sistema">Podešavanje sistema</a></td></tr>
                <tr><td><a href="#cas1">ČAS 1</a></td></tr>
                <tr><td><a href="#cas2">ČAS 2</a></td></tr>
                <tr><td><a href="#cas3">ČAS 3</a></td></tr>
                <tr><td><a href="#cas4">ČAS 4</a></td></tr>
                <tr><td><a href="#cas5">ČAS 5</a></td></tr>
                <tr><td><a href="#cas6">ČAS 6</a></td></tr>
                <tr><td><a href="#cas7">ČAS 7</a></td></tr>
                <tr><td><a href="#cas8">ČAS 8</a></td></tr>
                <tr><td><a href="#cas9">ČAS 9</a></td></tr>
                <tr><td><a href="#recap">SQL RECAP</a></td></tr>
                <tr><td><a href="#cas10">ČAS 10</a></td></tr>
                <tr><td><a href="#cas11">ČAS 11</a></td></tr>
                <tr><td><a href="#cas12">ČAS 12</a></td></tr>
                <tr><td><a href="#rokovi">Rokovi</a></td></tr>
            </table>
        </div>

        <div id="right_menu">
            <p> Kontakt: milica.gnjatovic[at]matf.bg.ac.rs</p>

            
            <h3><a href="http://www.bazepodataka.matf.bg.ac.rs/RelacioneBazePodataka.html#0_tab">Zvanična stranica predmeta</a></h3>

            <h3 class="obavestenje">Srećan početak novog semestra! <br>
                Sva važna obaveštenja će biti na zvaničnoj strani predmeta.</h3>
            
            
            <h1 id="podesavanje_sistema">Podešavanje sistema</h1>
            <p>Potrebni programi za vežbe će se ove godine razlikovati u odnosu na prethodnu. Umesto IBM DB2 sistema za upravljanje bazama podataka će se koristiti IBM DB2 docker slika. Ukoliko već imate instaliran DB2 i to može da se koristi.
                Umesto IBM Data Studio alat za rad sa bazama podataka će se koristiti alat JetBrains DataGrip. Studentska baza podataka <i>stud2020</i> ostaje ista kao i prehodnih godina.
                <br>
                Virtuelna mašina se više neće koristiti.
            </p>
            <p>
                Softver potreban za vežbe:
                <ul>
                    <li> Docker </li>
                    <li> JetBrains DataGrip</li>
                    <li> Studentska baza podataka <a href="./resources/rbp/stud2020.zip"><i>stud2020</i></a></li>
                </ul>

                Detaljno uputsvo za podešavanje sistema se nalazi u <a href="https://docs.google.com/document/d/1D7EvHbux6MGMxzpqcXCc4fJgAUCge4xP2m8aIgyznIw/edit?usp=sharing">dokumentu</a>.

                Nakon inicijalnog nameštanja sistema, komande koje Vam mogu biti potrebne su:

                <dl>
                    <dt>Pokretanja kontejnera mydb2 nakon što ponovo upalite računar:</dt>
                    <dd class="kod">docker start mydb2</dd>

                    <dt>Ulazak u terminal kontejnera:</dt>
                    <dd class="kod">docker exec -it mydb2 /bin/bash</dd>
                </dl>

                <h3> Struktura baze podataka </h3>
                <ul>
                    <li><b>DA</b> - podaci zapisani ASCII kodnom shemom</li>
                    <li><b>DB</b> - podaci zapisani UTF-8 kodnom shemom</li>
                </ul>

                <img src="resources/rbp/dijagram_stud2020.png" alt="stud2020" style="width: 100%;">

                <a href="https://drive.google.com/file/d/1DQc9YG0R8qLbfsjAjq-Jr6IogAZosXF7/view?usp=sharing" target="_blank">SQL Reference knjiga</a>

                <h1 id="cas1">ČAS 1</h1>

                <h3>Komande u db2:</h3>
                <div class="kod">
                    <table class="basic_underline">
                        <tr>
                            <td>db2start</td>
                            <td>pokretanje, nije potrebno u docker kontejneru</td>
                        </tr>
                        <tr>
                            <td>db2stop</td>
                            <td>zaustavljanje, nije potrebno u docker kontejneru</td>
                        </tr>
                        <tr>
                            <td>db2 list db directory </td>
                            <td>lista svih baza u sistemu</td>
                        </tr>
                        <tr>
                            <td>db2</td>
                            <td>pokretanje interkativnog okruženja</td>
                        </tr>
                        <tr>
                            <td>db2 connect to IME_BAZE</td>
                            <td>povezivanje na bazu podataka</td>
                        </tr>
                        <tr>
                            <td>db2 connect to IME_BAZE user IME_KORISNIKA using SIFRA</td>
                            <td>povezivanje na bazu podataka kao određeni korisnik</td>
                        </tr>
                        <tr>
                            <td>db2 connect reset</td>
                            <td>diskonektovanje</td>
                        </tr>
                        <tr>
                            <td>db2 list tables</td>
                            <td>prikaz tabela u bazi za podrazumevanu shemu</td>
                        </tr>
                        <tr>
                            <td>db2 values current schema</td>
                            <td>prikaz trenutne sheme</td>
                        </tr>
                        <tr>
                            <td>db2 list tables for schema IME_SHEME</td>
                            <td>prikaz tabela u bazi za određenu shemu</td>
                        </tr>
                        <tr>
                            <td>db2 describe table IME_TABELE/IME_SHEME.IME_TABELE </td>
                            <td>informacije o tabeli</td>
                        </tr>
                        <tr>
                            <td>db2 "UPIT" </td>
                            <td>dohvatanje podataka iz baze</td>
                        </tr>
                        <tr>
                            <td>db2 -f PUTANJA_DO_FAJLA -v </td>
                            <td>izvršavanje upita iz fajla, -v naglašava da se svaki upit završava sa <b>;</b>. Može se dodati -v da se prikaže upit koji je izvršen. U jednom fajlu može biti više upita.</td>
                        </tr>
                    </table>
                </div>

                <p><b>Baza podataka</b> - kolekcija podataka organizovana na određen način; različiti tipovi, objektne, nerelacione, relacione...</p>
                <p><b>Sistem za upravljanje bazom podataka (SUBP) </b>- program koji omogućava pristup i rad sa podacima iz baze, to je ibm db2.</p>
                <p><b>Relacione baze podataka (RBP)</b> - podaci se predstavljaju u okviru relacija/tabela</p>
                <p><b>Entitet</b> - neki objekat, prikazuje se tabelom; student, predmet, ispit...</p>
                <p><b>Atribut</b> - opisuje objekat, kolone tabele; indeks, ime, prezime...</p>
                <p><b>Student</b> (<u>indeks</u>, ime, prezime, datum_rođenja, mesto_rođenja)</p>
                <p><b>Red/ntorka</b> - podaci o jednom entitetu/studentu/ispitu...</p>
                <p><b>Relaciona baza</b> - skup relacija/tabela</p>
                <p><b>Relaciona shema</b> - opis strukture relacija</p>
                <p><b>SQL</b> - sredstvo za upravljanje relacionom bazom podatka, upitni jezik</p>
                <p><b>Primarni ključ</b> - atribut ili skup atributa koji jedinstveno opisuju entitet</p>
                <p><b>Strani ključ</b> - atribut ili skup atributa kojim se pravi veza ka drugoj relaciji</p>
                <p><b>Shema</b> - grupisane tabele u pogled koji čini celinu, npr. shema za profesore i shema za studente</p>

                <p>
                    <h3>Redosled izvršavanja:</h3>
                    3 SELECT <i>- kolone koje će se prikazati, * da se prikažu sve kolone </i> <br> 
                    1 FROM <i>- odakle izvlačimo podatke, koja tabela </i> <br>
                    2 WHERE <i>- uslovi koje rezultati treba da ispunjavaju</i><br>
                </p>

               
                <div id="cas1zadaci"></div>
                <script>
                    loadClassFromJSON("cas1zadaci", "resources/rbp/cas1.json")
                </script>


<!-- CAS2-->
            <h1 id="cas2">ČAS 2</h1>
            <h3>Vrste spajanja</h3>

            <img src="resources/rbp/spajanje.png" width="100" style="width: 100%;">

            <h3>Da li staviti uslov u WHERE ili u ON?</h3>
            Bitno nam je gde ide uslov kada imamo left ili right join. 
            Ako na primer tražimo da se izdvoje studenti i predmeti na kojima imaju desetke, 
            i oni studenti koji nemaju ni jednu desetku.
            <br>
            Ako izvršimo:
            <p class="kod">
            SELECT D.INDEKS, I.INDEKS, OCENA <br>
            FROM DA.DOSIJE D LEFT JOIN DA.ISPIT I <br>
            <tab></tab>    ON I.INDEKS=D.INDEKS AND OCENA>5 AND STATUS='o';
            </p>

            Imaćemo 33679 redova (bar kod mene). Neki od tih redova su
            <br>
            20171010      |     NULL  |    NULL
            <br> 
            20171106      |     NULL    |  NULL
            <br>
            20180087       |    NULL   |   NULL
            <br>
            
            To su studenti koji nemaju ni jedan položen ispit. 
            Dakle, sada imamo studente spojene sa njihovim ispitima, a ako nemaju ispite onda su spojeni sa NULL.
            <br>
            Ovde sada treba dodati uslov za 10ke.
            
            Ako dodamo samo
            <p class="kod">
            WHERE OCENA=10;
            </p>

            Dobićemo 7401 red, ali među njima će biti sve desetke.
            
            Izgubićemo prethodna 3 reda, a to su nam studenti koji nemaju ni jedan položen ispit (samim tim ni jednu 10ku), dakle želimo ih u rezultatu.
            
            Da bi ti redovi ostali potrebno je da uslov za 10 ide u ON:
            
            <p class="kod">
            SELECT D.INDEKS, I.INDEKS, OCENA <br>
            FROM DA.DOSIJE D LEFT JOIN DA.ISPIT I <br>
            <tab></tab>    ON I.INDEKS=D.INDEKS AND OCENA>5 AND STATUS='o' AND OCENA=10;
            </p>
            
            Sada imamo 9101 red i među njima i ona tri sa početka.
            <br>
            
            Ovo spajanje možemo da tumačimo ovako: 
            <blockquote>Svakog studenta iz tabele dosije probaj da spojiš sa njegovim ispitom na kom je dobio 10, ako takav ispit ne postoji ostavi studenta u rezultatu i spoji ga sa NULL.</blockquote>
            
            Još jedan način da ovo gledate je da pre nego dodamo onaj WHERE razmislimo koje vrednosti će da poredi. 
            U rezultatu pre toga smo videli da imamo redove gde je ocena null, znači da će where koji dodamo imati poređenje null=10. null=10 je false, pa će red time biti izbačen iz rezultata.
            
            Ovo razmatranje nam nije tako značajno ako imamo samo join jer će on spojiti samo studente sa njihovim ispitima, nećemo uopšte imati redove sa ocenom NULL na koje potencijalno treba da se pazi da se ne izgube dodavanjem where.
            
            <br><br>
            U prethodnim upitima namerno stoje D.INDEKS i I.INDEKS da bi obratili pažnju da su sve I.XXX vrednosti NULL ako ne postoji ispit sa kojim spajamo studenta.
        <div id="cas2zadaci"></div>
        <script>
            loadClassFromJSON("cas2zadaci", "resources/rbp/cas2.json")
        </script>
<!-- CAS2 KRAJ-->

<!-- CAS3-->
        <h1 id="cas3">ČAS 3</h1>
        <h3>Podupiti</h3>
        <dl>
            <dt>X [NOT] IN (SELECT Y FROM ... WHERE ...)</dt>
            <dd> Gledamo da li je X u nizu Y-ona koji dobijamo iz podupita. Važno je da X i Y imaju isti broj atributa. Na primer možemo imati WHERE (OZNAKAROKA, SKGODINA) IN (SELECT OZNAKA, GODINA FROM ...).  </dd>
            
            <dt>[NOT] EXISTS (SELECT ... FROM ...)</dt>
            <dd>Uslov je zadovoljen ako podupit vraća bar jedan red.</dd>

            <dt>X < ALL (SELECT ... FROM ...)</dt>
            <dd>Uslov je zadovoljen ako je X manje od svake vrednosti koju vraća podupit. Mogu se koristi i ostali operatori.</dd>

            <dt>X < SOME (SELECT ... FROM ...)</dt>
            <dd>Uslov je zadovoljen ako je X manje od neke vrednosti koju vraća podupit. Mogu se koristi i ostali operatori.</dd>

            <dt>X = ANY (SELECT ... FROM ...)</dt>
            <dd>Uslov je zadovoljen ako je X jednako nekoj vrednosti koju vraća podupit. Mogu se koristi i ostali operatori.</dd>

        </dl>

        <p>
        <b>SVAKI <=> NE POSTOJI NEKI KOJI NIJE</b>
        <br>
        Tražimo studenta koji je položio svaki ispit koji je polagao. <=> Tražimo studenta za kog NE POSTOJI ispit koji NIJE POLOŽIO.
        </p>

        <div id="cas3zadaci"></div>
        <script>
        loadClassFromJSON("cas3zadaci", "resources/rbp/cas3.json")
        </script>

        <h4>Napomene posle časa:</h4>
        <ul>
            <li>Drugom zadatku je dodata napomena uz još jedno rešenje.</li>
            <li>
                <p>U narednom primeru ćemo imati grešku jer se u order by ne zna da li želimo da uredimo po indeksu iz tabele dosije ili po indeksu iz tabele ispit. Možemo to rešiti tako što ćemo staviti order by D.INDEKS ili order by I.INDEKS.</p>
                <p class="kod">
                    SELECT *<br>FROM DA.ISPIT I JOIN DA.DOSIJE D<br><tab></tab>ON I.INDEKS = D.INDEKS<br>ORDER BY INDEKS;
                </p>
                <p>Međutim, u narednom primeru nemamo grešku jer se u select nalazi jedan indeks, pa se po njemu uređuje.</p>
                <p class="kod">SELECT D.INDEKS, IME<br>FROM DA.ISPIT I JOIN DA.DOSIJE D<br><tab></tab>ON I.INDEKS = D.INDEKS<br>ORDER BY INDEKS;</p>
            </li>
        </ul>
<!-- CAS3 KRAJ-->

<!-- CAS4 -->
<h1 id="cas4">ČAS 4</h1>
<h3>Skupovni operatori</h3>
<dl>
    <dt>UNION</dt>
    <dd>
        <i>upit1</i> UNION <i>upit2</i> nam daje sve redove iz upita1 i upita2 bez duplikata. Važno je da i prvi i drugi upit vraćaju isti broj kolona i da su te kolone istog tipa. Na primer u redu je ako prvi upit vraća ime (string), ocenu (broj), a drugi prezime (string), indkeks (broj). Nije u redu ako prvi vraca ocenu (broj), a drugi ime (string).
    </dd>

    <dt>UNION ALL</dt>
    <dd>Identično kao UNION samo što ovde možemo imati duplikate. Efikasnije je od UNION jer ne proverava duplikate. UNION je kao da smo na UNION ALL primenili DISITNCT.</dd>

    <dt>INTERSECT</dt>
    <dd>
        <i>upit1</i> INTERSECT <i>upit2</i> nam daje sve redove iz upita 1 koji postoje i u upitu 2 bez duplikata. Važno je da i prvi i drugi upit vraćaju isti broj kolona i da su te kolone istog tipa.
    </dd>

    <dt>INTERSECT ALL</dt>
    <dd>Identično kao INTERSECT samo što ovde možemo imati duplikate. Efikasnije je od INTERSECT jer ne proverava duplikate. INTERSECT je kao da smo na INTERSECT ALL primenili DISITNCT.</dd>

    <dt>EXCEPT / MINUS</dt>
    <dd> <i>upit1</i> EXCEPT <i>upit2</i> nam daje sve redove iz upita 1 koji ne postoje u upitu 2 bez duplikata. Važno je da i prvi i drugi upit vraćaju isti broj kolona i da su te kolone istog tipa. EXCEPT i MINUS su sinonimi i potpuno je svejedno da li koristimo jedno ili drugo.
    </dd>

    <dt>EXCEPT ALL</dt>
    <dd> <i>upit1</i> EXCEPT ALL <i>upit2</i> nam daje sve redove iz upita 1 koji ne postoje u upitu 2 uzimajući u obzir duplikate. Ako prvi upit vraća X za svaku ocenu 10, a drugi upit vraća X za svaku ocenu 6, i ako student ima 5 desetki i 3 šestice u rezultatu će biti 2 reda sa X. Ako bi u ovom primeru koristili samo EXCEPT dobili bi praznu tabelu kao rezultat.</dd>
</dl>

<h3>Funkcije za rad sa datumom i vremenom</h3>
<dl>
    <dt>CURRENT TIME, CURRENT DATE</dt>
    <dd>specijalni registri koji sadrže vrednost trenutnog vremena, odnosno datuma</dd>

    <dt>DATE(expression)</dt>
    <dd>expression može biti string u formatu "dd.mm.yyyy"</dd>
    
    <dt>YEAR(date)</dt>
    
    <dt>MONTH(date)</dt>
    <dd>redni broj meseca u godini</dd>
    
    <dt>WEEK(date)</dt>
    <dd>redni broj nedelje u godini</dd>
    
    <dt>DAY(date) / DAYOFMONTH(date)</dt>
    <dd>redni broj dana u mesecu</dd>

    <dt>DAYOFYEAR(date)</dt>
    <dd>redni broj dana u godini</dd>

    <dt>DAYOFWEEK(date)</dt>
    <dd>redni broj dana u nedelji, 1 je subota, dok je 7 nedelja</dd>

    <dt>DAYNAME(date)</dt>
    <dd>naziv dana u nedelji; ukoliko želimo da zadamo jezik možemo ga dodati kao drugi argument, za srpski bi kod bio 'sr_latn_sr' ili 'sr_cirilc_sr'</dd>

    <dt>MONTHNAME(date)</dt>
    <dd>naziv meseca; ukoliko želimo da zadamo jezik možemo ga dodati kao drugi argument, za srpski bi kod bio 'sr_latn_sr' ili 'sr_cirilc_sr'</dd>

    <dt>DAYS(date)</dt>
    <dd>brojevna reprezentacija datuma</dd>
    
    <dt>TIME(expression)</dt>
    <dd>vraća vreme, expression može biti u formatu hh:mm</dd>

    <dt>TIMESTAMP(date, time)</dt>
    <dd>vraća format koji sadrži datum i vreme</dd>

    <dt>HOUR(time), MINUTE(time), SECOND(time)</dt>
    <dd>vraća broj sati, minuta i sekundi za vreme</dd>

    <dt>YEARS_BETWEEN(date1, date2), MONTHS_BETWEEN(date1, date2), DAYS_BETWEEN(date1, date2)</dt>
    <dd>Koliko je godina, meseci, dana prošlo između dva datuma. Ako gledamo mesece na primer a prošlo je 2 godine i 3 meseca reulatat će biti 27 meseci, a ne 3.</dd>

    <dt>SECOND[S], MINUTE[S], HOUR[S], DAY[S], MONTH[S], YEAR[S]</dt>
    <dd>
        ključne reči koje nam omogućuju da dodajemo na neki datum ili na neko vreme <br>
        Na primer: 
            <ul>
                <li>CURRENT TIME + 5 MINUTES - 5 SECONDS</li>
                <li>DATE('1.1.2020') + 5 YEARS (u ovom slučaju nije dovoljno samo niska za datum, već je potrebno i DATE da se naglasi da je datum jer db2 ne može sam da zaključi)</li>
            </ul>
    </dd>
</dl>

<h3>Funkcije za rad sa karakterima</h3>
<dl>
    <dt>SUBSTR(str, start, len)</dt>
    <dd>Vraća podnisku niske str, koja počinje od start a dužine je len. Indeksiranje kreće od 1. Ukoliko se ne navede len izdvaja se podniska od pozicije start do kraja niske. </dd>

    <dt>CONCAT(x, y), x || y</dt>
    <dd>Spaja niske x i y. CONCAT prima tačno dva argumenta, dok ako koristimo operator || možemo ulančati više stringova (a || b || c ...).</dd>

    <dt>SPACE(x)</dt>
    <dd>Vraća x praznih mesta.</dd>

    <dt>POSSTR(x, y)</dt>
    <dd>Vraća indeks na kom počinje niska y u niski x. Ukoliko se y ne nalazi u x vraća 0.</dd>

    <dt>REPEAT(str, x)</dt>
    <dd>Ponavlja nisku str x puta.</dd>

    <dt>REPLACE(str, x, y)</dt>
    <dd>Zamenjuje sva pojavljivanja niske x u str sa y.</dd>

    <dt>LTRIM(str), TRIM(str), RTRIM(str)</dt>
    <dd>Uklanja beline levo, desno ili sa obe strane.</dd>

    <dt>LENGTH(arg)</dt>
    <dd>Vraća dužinu argumenta, koji može biti string ili broj.</dd>
</dl>

<h3>Funkcije za nedefinisane vrednosti</h3>
<dl>
    <dt>COALESCE(x, y, z...)</dt>
    <dd>Vraća prvi argument iz liste čija vrednost nije NULL. Ako su svi agumenti NULL onda se NULL i vraća.</dd>

    <dt>NULLIF(x, y)</dt>
    <dd>Vraća NULL ako su x i y jednaki. Ukoliko su argumenti različiti onda vraća prvi argumenti.</dd>
</dl>

<h3>Funkcije za konverziju</h3>
<dl>
    <dt>DECIMAL(x, y, z), DEC(x, y, z)</dt>
    <dd>Vraća decimalnu reprezentaciju x, pri čemu y predstavlja ukupan broj cifara, a z broj mesta iza decimalnog zareza. X može biti broj ili string.</dd>

    <dt>DOUBLE(x)</dt>
    <dd>Vraća broj veće preciznosti. X može biti string ili broj.</dd>

    <dt>DECIMAL(expression)</dt>
    <dd>Vraća string reprezentaciju broja.</dd>

    <dt>CHAR(expression)</dt>
    <dd>Skoro sve tipove pretvara u string.</dd>

    <dt>CHAR(datetime, format)</dt>
    <dd>Datum i vreme prikazuje u datom formatu. Dostupni formati su ISO, USA, EUR, JIS, LOCAL.</dd>
</dl>

<h3>Numeričke funkcije</h3>
<dl>
    <dt>MOD(x, y)</dt>
    <dt>ABS(x)</dt>
    <dt>SIGN(x)</dt>
    <dd>Vraća 1 za pozitivne, -1 za negativne, 0 za 0.</dd>
    <dt>SQRT(x)</dt>
    <dd>Vraća koren broja.</dd>
    <dt>RAND(seed)</dt>
    <dd>Vraća random broj. Seed argument nije obavezan, za isti seed se dobija isti 'random' broj.</dd>
    <dt>CEIL, FLOOR</dt>
    <dd>Zaokružuje broj na veći, odnosno manji.</dd>
    <dt>SIN, COS, TAN, COTAN, ASIN, ACOS, ATAN, EXP...</dt>
    <dt>ROUND(num, broj_decimala)</dt>
</dl>

<p>Na narednom linku možete naći još sklarnih funkcija i informacije o njima: <a href="https://www.ibm.com/docs/en/db2/11.5?topic=functions-scalar">dokumentacija</a>.</p>
<div id="cas4zadaci"></div>
    <script>
    loadClassFromJSON("cas4zadaci", "resources/rbp/cas4.json")
    </script>
<!-- CAS4 KRAJ-->

<!-- CAS5-->

    <h1 id="cas5">ČAS 5</h1>

    <img src="/resources/rbp/groupby.png" alt="group by" style="width:100%;">

    <div id="cas5zadaci"></div>
    <script>
    loadClassFromJSON("cas5zadaci", "resources/rbp/cas5.json")
    </script>
<!-- CAS5 KRAJ-->

<!-- CAS6-->

<h1 id="cas6">ČAS 6</h1>
<h3>WITH klauza</h3>
<p>With klauzom možemo definisati privremenu tabelu koju koristimo u upitu.</p>
<p class="kod">
    <b>WITH</b> POMOCNA_TABELA <b>AS</b> (<br>
        <tab></tab> SELECT ... FROM ... <br>
    )<br>
    SELECT ... <br> 
    FROM POMOCNA_TABELA <br>
    ...
</p>

<p class="kod">
    <b>WITH</b> POMOCNA_TABELA(kolona1, kolona2 ...) <b>AS</b> (<br>
        <tab></tab> SELECT ... FROM ... <br>
    )<br>
    SELECT ... <br> 
    FROM POMOCNA_TABELA <br>
    ...
</p>

<p>Pomoćnu tabelu možemo koristiti kao i bilo koju drugu tabelu iz baze, možemo je spajati sa drugim tabelama, grupisati... <br>
    Možemo definisati više pomoćnih tabela:
    
    <p class="kod">
        <b>WITH</b> POMOCNA_TABELA <b>AS</b> (...), <br>
        <tab></tab> DRUGA_POMOCNA_TABELA <b>AS</b> (...), <br>
        <tab></tab> ... <br>
        SELECT ... <br> 
        FROM ... <br>
        WHERE ...
    </p>

    Važno je da pri definisanju pomoćne tabele svakoj koloni damo ime.</p>
<div id="cas6zadaci"></div>
<script>
loadClassFromJSON("cas6zadaci", "resources/rbp/cas6.json")
</script>
<!-- CAS6 KRAJ-->


<!-- CAS7-->

<h1 id="cas7">ČAS 7</h1>
<h2>Kreiranje tabela</h2>
<p class="kod">
    <b>CREATE TABLE</b> NAZIV_TABELE (<br>
    <tab></tab>NAZIV_KOLONE1 TIP_KOLONE1 <br>
    <tab></tab>NAZIV_KOLONE2 TIP_KOLONE2 <b>NOT NULL</b> <br>
    <tab></tab>NAZIV_KOLONE3 TIP_KOLONE2 <b>DEFAULT ... </b> <br>
    <tab></tab>...<br>
    <tab></tab>NAZIV_KOLONEN TIP_KOLONEN <br>
    <tab></tab><b>PRIMARY KEY</b> (KOLONA_KLJUC1, KOLONA_KLJUC2...) <br>
    <tab></tab><b>FOREIGN KEY</b> FK_NAZIV_KLJUCA (NAZIV_KOLONE_OVE_TABELE) <b>REFERENCES</b> NAZIV_TABELE_KOJU_REFERISE <br>
    <tab></tab><b>CONSTRAINT</b> NAZIV_OGGRANICENJA <b>CHECK</b> ( ... )<br>
    ) 
</p>

<p>
    Primarni ključ može činiti više kolona. Važno je da svaka kolona bude definisana sa NOT NULL. Primarni ključ se još može definisati tako što u nazivu kolone dodamo primary key, npr ID INTEGER NOT NULL PRIMARY KEY.<br>
    Umesto komande CREATE TABLE ... , možemo korisiti CREATE TABLE <b>IF NOT EXISTS</b> ... kojom kreiramo tabelu samo ukoliko ona već ne postoji. <br>
    
    Ukoliko ne želimo ručno da unosimo vrednost primarnog ključa ona može automatski da se generiše:
    <ul>
        <li>
            <p class="kod">NAZIV_KOLONE INTEGER NOT NULL <b>GENERATED ALWAYS AS IDENTITY</b> (MINVALUE 1)</p>
            <p>U ovom slučaju vrednost ne možemo da unosimo ručno već se uvek automatski dodaje. Minval je opciono.</p>
        </li>

        <li>
            <p class="kod">NAZIV_KOLONE INTEGER NOT NULL <b>GENERATED BY DEFAULT AS IDENTITY</b> </p>   
            <p>Vrednost se dodaje automatski ukoliko nije navedena.</p>
        </li>
    </ul>
    <p>Više o ovome se može naći u <a href="https://www.ibm.com/docs/en/db2-warehouse?topic=concepts-auto-numbering-identifier-columns">dokumentaciji</a>.</p>
</p>
Neki od dozvoljenih tipova za kolone su:
<ul>
    <li>SMALLINT, INTEGER/INT, BIGINT, DECIMAL/DEC, FLOAT(BROJ DECIMALA), REAL, DOBULE</li>
    <li>CHARACTER/CHAR</li>
    <li>CHARACTER/CHAR[max broj karaktera u niski]</li>
    <li>VARCHAR[max broj karaktera u niski]</li>
    <li>DATE, TIME, TIMESTAMP</li>
    <li>BOOLEAN</li>
</ul>

<p>Lista tabela u bazi se može videti sa nekom od narednih komandi iz terminala:</p>
<ul>
    <li class="kod">db2 lista tables</li>
    <li class="kod">db2 lista tables for naziv_sheme</li>
</ul>
<p>Treba obratiti pažnju gde je kreirana baza, tj. da li u nekoj shemi.</p>

<h2>Kopiranje tabele </h2>
<p class="kod">
    <b>CREATE TABLE</b> NAZIV_KOPIJE_SA_PODACIMA <b>AS</b> (<br>
	<tab></tab>SELECT *<br>
	<tab></tab>FROM ORIGINALNA_TABELA<br>
) <b>WITH DATA</b>;
</p>
<p class="kod">
    <b>CREATE TABLE</b> NAZIV_KOPIJE_BEZ_PODATAKA <b>AS</b> (<br>
	<tab></tab>SELECT *<br>
	<tab></tab>FROM ORIGINALNA_TABELA<br>
) <b>WITH NO DATA</b>;

<p>Ovo je korisno ako želite da vežbate izmenu i brisanje redova, a da pri tom ne menjate originalnu tabelu.</p>

<h2>Promena strukture tabele</h2>
<p class="kod"> <b>ALTER TABLE</b> NAZIV_TABELE ... </p>
Moguće su naredne izmene:
<ul>
    <li class="kod"> DROP NAZIV_KOLONE </li>
    <li><p class="kod"> ADD NAZIV_KOLONE TIP_KOLONE</p>
        Ukoliko ne navedemo DEFAULT NEKA_VREDNOST, vrednosti koje su već bile u bazi će za vrednost u toj koloni imati NULL.
        Ukoliko želimo da ta kolona koju dodajemo bude NOT NULL moramo obavezno navesti podrazumevanu vrednost.
    </li>
    <li class="kod"> ADD CONSTRAINT NAZIV_OGRANICENJA CHECK (...) </li>
    <li class="kod"> DROP CONSTRAINT NAZIV_OGRANICENJA </li>
    <li class="kod"> ALTER COLUMN NAZIV_KOLONE SET DEFAULT .... </li>
</ul>

Nakon promene strukture tabele u nekim slučajevima je neophodno reorganizovati tabelu komandom iz terminala:
<p class="kod">
    db2 connect to naziv_baze <br>
    db2 reorg table naziv_tabele
</p>

<h2>Brisanje tabele iz baze</h2>
<p class="kod"><b>DROP TABLE</b> NAZIV_TABELE;</p>
<p class="kod"><b>DROP TABLE IF EXISTS</b> NAZIV_TABELE;</p>
Ukoliko pokušamo da obrišemo tabelu koja ne postoji prva verzija će izbaciti grešku, dok druga neće.

<h2>Dodavanje redova u bazu</h2>
<p class="kod">
    <b>INSERT INTO </b> NAZIV_TABELE(KOL1, KOL2, ... , KOLN) <b>VALUES</b> <br>
    <tab></tab> (VREDNOST_KOL1, VREDNOST_KOL2, ... , VREDNOST_KOLN), <br>
    <tab></tab> (VREDNOST_KOL1, VREDNOST_KOL2, ... , VREDNOST_KOLN), <br>
    <tab></tab>...
</p>
<p class="kod">
    <b>INSERT INTO </b> NAZIV_TABELE(KOL1, KOL2, ... , KOLN)<br>
    SELECT ... <br>
    FROM ...
</p>
<p>Ukoliko se ubacuje vrednost za svaku kolonu redom onda nije neophodno navoditi nazive kolona. Vrednosti koje se ne unesu će biti NULL.</p>

<h2>Izmena podataka u bazi</h2>
<p class="kod">
    <b>UPDATE</b> NAZIV_TABELE <br>
    <b>SET</b> KOL1 = VREDNOST,<br>
    <tab></tab>KOL2 = CASE WHEN ... THEN ... ... END<br>
    <tab></tab>KOL3 = (SELECT ... FROM ... WHERE)<br>
    <tab></tab>KOL4 = ... <br>
    WHERE ... 
</p>
<p class="kod">
    <b>UPDATE</b> NAZIV_TABELE <br>
    <b>SET</b> (KOL1, KOL2 ...) = (VREDNOST1, VREDNOST2, ...) <br>
    WHERE ... 
</p>

Ako ne navedemo WHERE izmeniće se svi redovi.

<h2>Brisanje redova iz baze</h2>
<p class="kod">
    <b>DELETE FROM</b> NAZIV_TABELE <br>
    WHERE ...
</p>
Ukoliko ne navedemo where biće obrisani svi redovi iz navedene tabele.

<div id="cas7zadaci"></div>
<script>
loadClassFromJSON("cas7zadaci", "resources/rbp/cas7.json")
</script>
<!-- CAS7 KRAJ-->

<!-- CAS8-->
<h1 id="cas8">ČAS 8</h1>
<h2>Pogled</h2>
<p class="kod">
    <b>CREATE VIEW</b> IME_POGLEDA <b>AS</b><br>
    SELECT ... <br>
    FROM ... <br>
    WHERE ... <br>
    [WITH CHECK OPTION]
</p>

<p class="kod"><b>DROP VIEW</b> IME_POGLEDA;</p>

<p>
    Originalna tabela može da se menja preko pogleda samo ako je pogled definisan nad jednom tabelom. Ukoliko bi nam bilo potrebno spajanje više tabela, to može da se zaobiđe podupitima.
    Ukoliko kolona nije navedena u pogledu pri unosu će njena vrednost biti null. Zbog ovoga je važno da ukoliko radimo unos preko pogleda u pogledu budu navedene sve not null kolone. 
    Koje kolone su not null možemo videti u komandi za kreiranje tabele ili na dijagramu. <br>
    With check option navodimo ukoliko želimo da se pri unosu proveri da li dati red zadovoljava uslov pogleda. 
    Na primer, ako pogleda sadrži studente upisane posle 2018e:
    <ul>
        <li>Ukoliko je pogled defisnisan BEZ with chevk opcije moći ćemo da unesemo studenta upisanog na primer 2015e. Ovaj student će biti unet u tabelu, ali nećemo moći da ga vidimo preko pogleda (jer je pogled definisan tako da prikazuje studente upisane posle 2018e).</li>
        <li>Ukoliko je pogled definisan SA with check opcijom preko njega nećemo moći da unesemo studenta uposanog pre 2018e.</li>
    </ul>
</p>

<h2>Indeksi</h2>
<img src="./resources/rbp/index.gif" alt="index" style="width: 80%;">
<p class="kod">
    <b>CREATE INDEX</b> NAZIV_INDEKSA<br> 
    <b>ON</b> NAZIV_TABELE <br> 
    <tab></tab>(kol1 ASC, kol2 DESC, kol3...);
</p>

<p class="kod">
    <b>DROP INDEX</b> NAZIV_INDEKSA;
</p>

<h2>Korisnički definisane funkcije</h2>
<p class="kod">
    <b>CREATE FUNCTION</b> IME_FUNKCIJE (ARG1 ARG1_TIP, ARG2 ARG2_TIP...)<br>
    <b>RETURNS</b> TIP_POVRATNE_VREDNOSTI<br>
    <b>RETURN</b> IZRAZ_KOJI_RAČUNA_REZULTAT

</p>
<p class="kod"><b>DROP FUNCTION</b> IME_FUNKCIJE;</p>

<p>
    Pri kreiranju korisnički definisanih funkcija treba obratiti pažnju na sledeće:
    <ul>
        <li>Izbegavati nazivanje argumenata funkcije kao kolone tabele koja se koristi. Ako na primer imamo argument funkcije INDEKS i poređenje D.INDEKS=INDEKS poređenje će uvek vraćati true. Odnosno dobićemo više redova umesto jedne vrednosti. Greška se ovde vidi tek pri pozivu funkcije.</li>
        <li>Tipovi argumenta sa kojim se poziva funkcija treba da se poklope sa vrednošću sa kojom se poziva funkcija. Ako ćemo na primer prosleđivati indeks kao argument, u funkciji mora biti integer tip argumenta, ako bi stavili smallint dobili bi grešku pri pozivu funkcije.</li>
        <li>Možemo imati više funkcija istog naziva koje primaju različite argumente. Koja funckija će biti pozvana zavisi od tipa argumenta. Ako imamo dve funkcije CENA, jedna prima INTEGER, druga SMALLINT. Ako pozovemo funkciju sa velikim brojem (više nego što samllint dozvoljava), biće pozvana funkcija koja prima INTEGER. Ako pozovemo sa 123 na primer, opet će biti pozvana za integer jer se vrši sutomatsko kastovanje. Ako želimo da naglasimo da se poziva funkcija za smallint potrebano je da vršimo kastovanje: SMALLINT(123). Identično može da uradi za integer: INTEGER(123).
            Drugi problem ako imamo više funkcija istog naziva je njihovo brisanje. Ako pokušamo DROP FUNCTION CENA neće uspeti jer sistem ne zna koju od dve funkcije da obriše. 
            Da bi obrisali odgovarajuću funkciju moramo da naglasimo koju želimo, to radimo tako što stavimo koji je tip argumenta: DROP FUNCITON CENA(INTGER), ili DROP FUNCTION(SMALLINT). Tip nije potreban ako imamo samo jednu funkciju.
            Možemo imati funkcije istog naziva i različitog broja argumenata.
        </li>
    </ul>
</p>

<h2>Gde naći šta sve ima u bazi?</h2>
<p>Sve tabele se nalaze u tabeli SYSCAT.TABLES. Ako želimo samo tabele neke scheme možemo iskorisiti naredni upit:</p>
<p class="kod">
SELECT *<br>
FROM SYSCAT.TABLES<br>
WHERE TABSCHEMA = 'DA';
</p>

Sve poglede možemo naći u tabeli SYSCAT.VIEWS. Kolona OWNERTYPE može imati vrednosti S (system) i U (user), to možemo koristiti da lakše nađemo poglede koje smo mi kreirali.
<p class="kod">
SELECT *<br>
FROM SYSCAT.VIEWS <br>
WHERE OWNERTYPE = 'U';
</p>
<p>Indeksi se mogu naći u tabeli SYSCAT.INDEXES.</p>
<p class="kod">
    SELECT *<br>
    FROM SYSCAT.INDEXES <br>
    WHERE OWNERTYPE = 'U';
    </p>
<p>Sve funkcije se nalaze u tabeli SYSCAT.FUNCTIONS.</p>
<p class="kod">
    SELECT *<br>
    FROM SYSCAT.FUNCTIONS;
</p>

<div id="cas8zadaci"></div>
<script>
loadClassFromJSON("cas8zadaci", "resources/rbp/cas8.json")
</script>
<!-- CAS8 KRAJ-->

<!-- CAS9-->
<h1 id="cas9">ČAS 9</h1>
<h2>LISTAGG</h2>
<p>Listagg je agregatna funkcija koja spaja stringove iz grupe u jedan.</p>
<p class="kod">
    SELECT LISTAGG(STRING, SEPARATOR) WITHIN GROUP(ORDER BY ...)<br>
    FROM ... <br>
    GROUP BY ...; 
</p>
Withing group (order by) je opcioni argument.<br>
Ukupna dužina teksta ne može biti veća od 4000 karaktera.
STRING može biti neka kolona, kol1 || kol2, DISTINCT kol...

<h2>MERGE</h2>
<p class="kod">
    <b>MERGE INTO</b> IME_TABELE <br>
    <b>USING</b> (NEKI_UPIT) <br>
    <b>ON</b> USLOV_POKLAPANJA <br>
    <b>WHEN MATCHED THEN</b> <br>
    <tab></tab>... <br>
    <b>WHEN MATCHED AND ... THEN</b> <br>
    <tab></tab>... <br>
    <b>WHEN NOT MATCHED THEN</b><br>
    <tab></tab>... <br>
    <b>WHEN NOT MATCHED AND ... THEN</b><br>
    <tab></tab>... <br>

</p>

<h2>Okidači</h2>
<p class="kod">
    <b>CREATE TRIGGER</b> NAZIV_TRIGERA<br>
    <b>BEFORE/AFTER INSERT/UPDATE/DELETE</b><br>
    <b>ON</b> NAZIV_TABELE<br>
    <b>REFERENCING</b><br>
    <tab></tab> OLD AS STARI<br>
    <tab></tab> NEW AS NOVI<br>
    <b>FOR EACH ROW</b><br>
    <b>WHEN</b>(USLOV_KOJI_ISPUNJAVAJU_REDOVI_NA_KOJE_CE_SE_PRIMENITI_TRIGGER)<br>
    <b>BEGIN ATOMIC</b><br>
    <tab></tab>    ... ; <br>
    <tab></tab>    ... ; <br>
    <tab></tab>    ... ; <br>
    <b>END</b> @
</p>

<h2>Izvršavanje okidača</h2>
<p>Jako je bitno da znamo šta koja vrsta triggera radi da bi znali kada se koja koristi.</p>
<div class="triangle"><b>BEFORE TRIGGER</b>
    <ul>
        <li>možemo sprečiti operaciju (unos, brisanje, izmenu) tako što ćemo iskoristiti SQLSTATE</li>
        <li>možemo izmeniti vrednosti koje se ubacuju ili menjaju (npr. probamo da unesemo ocenu 11, umesto da javimo grešku mi postavimo ocenu na 10)</li> 
        <li>izmena unosa se radi sa SET N.KOL = ..., ovde NE radimo INSERT, UPDATE, DELETE, jer nakon ovog triggera će se vrednost stvarno uneti, to NE RADI TRIGGER</li> 
        <li>Ukoliko treba nakon unosa ocena da se nešto upiše u neku drugu tabelu to se radi u AFTER TRIGGERU, zato što before trigger može da spreči unos (odnosno može da se desi da smo u before triggeru izmenili prosek studenta jer je dobio 10, ali da se javi greška pa da se ta 10ka ne unese u bazu, prosek u toj drugoj tabeli neće biti tačan jer 10ka nije stvarno uneta)</li> 
    </ul>
</div>
<div class="triangle"><b>Unos podataka</b> 
    <ul>
        <li>podaci se fizički upisuju u tabelu</li>
        <li>prethodno smo mogli imati OLD vrednost, nakon ovoga nemamo jer smo upisali podatke preko nje</li>
    </ul>
</div>
<div class="triangle-end"><b>AFTER TRIGGER</b> 
    <ul>
        <li>ovde se tipično može raditi sa nekom drugom tabelom (na primer uneli smo ocenu 10 iz P1, onda na primer u tabelu u kojoj su proseci studenata izmenimo prosek studenta koji je dobio tu desetku)</li>
        <li>ovde se NE SME raditi nešto što će opet okinuti isti okidač (na primer ako unosimo komentar u neku tabelu, ako u after triggeru za taj unos imamo insert u istu tabelu, onda će se opet okinuti isti trigger za unos komentara, koji će opet nešto uneti, i tako u beskonačnost... Eventualni izuzetci su neki uslovi koji će zaustaviti ovaj niz unosa, ali to se generalno NE RADI)</li>
    </ul> 
</div>

<h2>NEW/OLD</h2>
<table class="trigger-tabela">
    <tr><th></th><th>OLD</th><th>NEW</th></tr>
    <tr><td>INSERT</td>
        <td><b>X</b> <br>Unosimo vrednos, nije bilo ništa prethodno.</td>
        <td><b>O</b><br> Vrednos koju unosimo, možemo je izmeniti preko new.</td></tr>
    <tr><td>UPDATE</td>
        <td><b>O</b><br>Vrednost koja je pretodno bila u tabeli, ne možemo nju menjati, ali na osnovu nje možemo menjti novu vrednost.</td>
        <td><b>O</b><br>Vrednost koju postavljamo, možemo je menjti.</td></tr>
    <tr><td>DELETE</td>
        <td><b>O</b><br>Vrednost koju pokušavamo da obrišemo, možemo proveriti da li ova vrednost zadovoljava neki uslov, pa da ne izvršimo brisanje ako zadovoljava.</td>
        <td><b>X</b><br>Obrisali smo vrednost, nema ništa više i ne znamo šta je bilo.</td></tr>
</table>

<p><b>Napomena:</b> OLD vrednost ako imamo one su u BEFORE triggeru, NEW vrednosti možemo imati u BEFORE i AFTER.</p>

<p>Kada radimo sa triggerima u većini slučajva ćemo imati više naredbi u telu i te naredbe treba razdvojiti sa ";". Ali ako ";" iskoistimo unutar kreiranja triggera (koji je jedna komanda), onda ne možemo to iskoristiti za kraj naredbe.
    Zbog toga uvodimo novi terminator, tipično @. 
</p>
<p class="kod">--#SET TERMINATOR @</p>
<p>Komanda ide baš ovako, -- u ovom slučaju ne gledaju ovo kao komentar. <br>
Ukoliko izvršavamo komande preko terminala koristimo narednu komandu:</p>
<p class="kod">db2 -td@ -f putanja_do_fajla</p>
<p>Ukoliko želimo da trigger javi grešku i zaustavi operaciju:</p>
<p class="kod">SIGNAL SQLSTATE '75000' ('Poruka o grešci koja će se ispisati korisniku.')</p>
<p>Sve triggere možemo videti u tabeli SYSCAT.TRIGGERS.</p>
<div id="cas9zadaci"></div>
<script>
loadClassFromJSON("cas9zadaci", "resources/rbp/cas9.json")
</script>
<!-- CAS9 KRAJ-->

    <h1 id="recap">SQL RECAP</h1>
    <img src="./resources/rbp/recap.png" alt="recap" style="width: 100%;">

<!-- CAS10 -->
<h1 id="cas10">ČAS 10</h1>
<h2>Relaciona algebra</h2>
<h3>Tabele sa kojima ćemo raditi:</h3>
<table id="relacione-tabele">
    <tr>
        <th>DOSIJE</th>
        <th>PREDMET</th>
        <th>ISPITNIROK</th>
        <th>ISPIT</th>
    </tr>
    <tr>
        <td>indeks<br>
            ime<br>
            prezime<br>
            mestorodjenja<br>
            datupisa</td>
        <td>idpredmeta<br>
            oznaka<br>
            naziv<br>
            espb</td>
        <td>
            skgodina<br>
            oznakaroka<br>
            naziv</td>
        <td>
            indeks<br>
            idpredmeta<br>
            skgodina<br>
            oznakaroka<br>
            ocena<br>
            datpolaganja<br>
            bodovi</td>
    </tr>
</table>

<h2>Osnovne operacije</h2>
<dl>
    <dt>Projekcija</dt>
    <dd>biramo atribute/kolone<br>
        kao SELECT <br>
        TABELA<b>[</b>kol1, kol2...<b>]</b>
    </dd>
    <dt>Restrikcija/Selekcija</dt>
    <dd>biramo redove koje želimo u rezultatu<br>
        kao WHERE <br>
        tabela <b>WHERE</b> ...
    </dd>
    <dt>Proizvod</dt>
    <dd>Dekartov proizvod - spaja svaki red jedne tabele sa svakim redom druge tabele<br>
        u SQL-u: from tab1,tab2<br>
        tab1 <b>TIMES</b> tab2
    </dd>
    <dt>Unija</dt>
    <dd> spajaju se redovi rezultata jednog upita sa redovima drugog upita<br>
        u SQL-u: UNION <br>
        upit1 <b>UNION</b>
    </dd>
    <dt>Presek</dt>
    <dd> zadržavaju se redovi koji se nalaze u rezultatima oba upita<br>
        u SQL-u: INTERSECT <br>
        upit1 <b>INTERSECT</b>
    </dd>
    <dt>Razlika</dt>
    <dd> zadržavaju se redovi koji se nalaze u rezultatima prvog upita, ali ne u rezultatu drugog upita<br>
        u SQL-u: MINUS, EXCEPT <br>
        upit1 <b>MINUS</b> upit2
    </dd>
    <dt>Slobodno spajanje</dt>
    <dd>restrikcija proizvoda dveju relacija<br>
        (tab1 TIMES tab2) WHERE A.x=B.y
    </dd>
    <dt>Prirodno spajanje</dt>
    <dd>spaja se po kolonama koje imaju isti NAZIV i OPSEG(TIP)<br>
        u SQL-u uz join ide ON uslov, dok ovde ne navodimo uslov, već se on podrazumeva<br>
        tab1 <b>JOIN</b> tab2</dd>
    <dt>Deljenje</dt>
    <dd>
        <ul>
            <li>Relacija A ima grupe kolona X i Y</li>
            <li>Relacija B ima grupu kolona Y</li>
            <li>Relacija B ima neke redove</li>
            <li>Delimo A sa B i u rezultatu dobijamo kolone X iz A takve da važi da je taj red u A uparen sa svim redovima iz B</li>
        </ul>
        Primeri:
        <img src="./resources/rbp/divide1.png" alt="divide" style="width: 100%;">
        <ol>
            <li> primer: U rezultatu se nalaze redovi koji su u A upareni sa p2 (iz B).</li>
            <li> primer: U A postoje redovi s1-p2 i s1-p4 pa s1 ide u rezultat. Postoje redovi s4-p2 i s4-p4 pa i s4 ide u rezultat. Da bi se s2 našao u rezultatu bilo bi porebno da postoje reodvi a2-p2(postoji) i s2-p4(ne postoji). Identično za s3.</li>
            <li> primer: Samo za vrednost s1 u A postoje parovi sa sve tri vrednost iz B, tj s1-p2, s1-p4 i s1-p1.</li>
        </ol>
    </dd>
</dl>

<h2>Izvršavanje koda</h2>
<p>Za primere urađene na vežbama i date za vežbu rezultat možete videti pomoću parsera za relacioni račun i relacionu algebru koleginice Ane Vulović u sintaksi koja se koristi na vežbama.
    Pomoću .deb paketa možete instalirati program na Ubuntu. Ovaj parser ne morate instalirati na virtuelnoj mašini za vežbe, već možete i na svom Linux sistemu.
    <br><br>
    <b>Na Ubuntu 20.04</b> - focal verzija<br>
    <i>sudo dpkg -i ./ime_preuzetog_fajla</i><br>
    ili sa<br>
    <i>sudo apt install ./ime_preuzetog_fajla</i><br><br>
    
    <b>Na Ubuntu 18.04 - 19.*</b> - bionic verzija<br>
    <i>sudo dpkg -i ./ime_preuzetog_fajla</i><br>
    ili sa<br>
    <i>sudo apt install ./ime_preuzetog_fajla</i> </p>
    <b>ime_preuzetog_fajle</b> bi treblo da bude <i>24-rarrchecker_1.0-1_amd64_bionic.deb</i> ili <i>24-rarrchecker_1.0-1_amd64_focal.deb</i>.<br><br>
    Možete probati da intalirate dvoklikom na preuzeti <i>.deb</i> fajl, tima ćete otvoriti Linux Software Installer. <br>
    <a href="./resources/rbp/24-rarrchecker_1.0-1_amd64_bionic.deb">rarrchecker_1.0-1_amd64_bionic.deb </a><br>
    <a href="./resources/rbp/24-rarrchecker_1.0-1_amd64_focal.deb">rarrchecker_1.0-1_amd64_focal.deb </a><br>

    <p>Kad instalirate parser možete ga naći među aplikacijama u meniju, ikonica je:</p>
    <img src="./resources/rbp/rarr.png" alt="rarr ikona"></img>

    <p>Ukoliko nemate odgovarajuće podatke u parseru možete ih učitate iz <a href="./resources/rbp/mala_studentska_baza.sql">datoteke</a>.
    U parseru idete menu > create database, zatim izaberete preuzetu datoteku. U datoteku možete dodati podatke ukoliko želite. </p>

<div id="cas10zadaci"></div>
<script>
loadClassFromJSON("cas10zadaci", "resources/rbp/cas10.json")
</script>
<!-- CAS10 KRAJ-->

<!-- CAS11-->
<h1 id="cas11">ČAS 11</h1>
<h2>Relacioni račun</h2>
<dl>
    <dt>Projekcija</dt>
    <dd>biramo atribute/kolone<br>
        range of red is relacija <br>
        red.A, red.B
    </dd>
    <dt>Restrikcija/Selekcija</dt>
    <dd>biramo redove koje želimo u rezultatu<br>
        range of red is relacija <br>
        red.X <br>
        <b>WHERE</b> ...
    </dd>
    <dt>Proizvod</dt>
    <dd>Dekartov proizvod - spaja svaki red jedne tabele sa svakim redom druge tabele<br>
        range of px is predmet <br>
        range of ix is ispit
    </dd>
    <dt>exists x (uslov)</dt>
    <dd>Navedeni uslov mora da važi za bar jednu n-torku x. Domen relacije x je samo uslov, ne možemo ga koristiti van zagrada uslova.</dd>
    <dt>forall x (uslov)</dt>
    <dd>Navedeni uslov mora da važi za sve n-torke iz x.  Domen relacije x je samo uslov, ne možemo ga koristiti van zagrada uslova.<br>
        forall x (uslov)  <=> not exists x (not uslov)
    </dd>
    <dt>Implikacija</dt>
    <dd>if form1 then form2 <br>
        if a then b <=> not p or q 
    </dd>
</dl>
<p>Ako radimo nad dve tabele, na primer predmet i ispit. U rezultatu možemo izdvojiti samo kolone iz na primer predmeta, ali onda kolone iz ispita ne možemo imati u where. Da bi u ovom slučaju gli da koristimo kolone iz where potrebno je da ispisujemo bar jednu kolonu iz tabele ispit (ne nužno onu koju koristimo) ili da koristimo exists/forall.</p>
<ul>
    <li>exists x exists y (...) <=> exists y exists x (...)</li>
    <li>forall x forall y (...) <=> forall y forall x (...)</li>
    <li>forall x exists y (...) <=/=> exists y forall x (...)</li>
    <li>forall(if p then q) <=> <br>
        forall (not p or q) <=> <br>
        not exists (not (not p or q)) <=> <br>
        not exists (p and not q)</li>
</ul>
<div id="cas11zadaci"></div>
<script>
loadClassFromJSON("cas11zadaci", "resources/rbp/cas11.json")
</script>
<!-- CAS11 KRAJ-->

<!-- CAS12-->
<h1 id="cas12">ČAS 12</h1>
<div id="cas12zadaci"></div>
<script>
loadClassFromJSON("cas12zadaci", "resources/rbp/cas12.json")
</script>

<h2>Primer ispita</h2>
<a href="./resources/rbp/rokovi/primerispita.pdf" target="_blank"> Zadaci </a><br>
<a href="./resources/rbp/rokovi/res_primerispita.txt" target="_blank">Rešenje</a>

<h2>Zadaci za vežbanje relacionog računa i algebre</h2>
<a href="./resources/rbp/racunalgebravezbanje.pdf" target="_blank">Zadaci</a>
<!-- CAS12 KRAJ-->

<h1 id="rokovi">Rokovi</h1>
<div id="rokoviLinkovi"></div>
<script>
    dohvatiRokove()
</script>

<p>
    <h3>Snimci konsultacija na kojima su rađeni rokovi:</h3>
    <a href="https://matf.webex.com/matf/ldr.php?RCID=b0afc06aaaf21d9bece2396fabd8a2df" target="_blank">Snimak 3.1, jan1 2022</a>, šifra: <b>Rbp03.01</b><br>
    <a href="https://matf.webex.com/matf/ldr.php?RCID=cc91eeb2f7f3f6f31a9bd8d07498f185" target="_blank">Snimak 5.1, sep1 2021</a>, šifra: <b>Rbp05.01</b>

</p>

<!-- levi div-->
         </div>

    </main>

</body>
</html>
